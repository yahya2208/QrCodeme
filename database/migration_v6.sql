-- ============================================
-- QRme - ARCHITECTURE V6: FULL AUTH SYSTEM
-- ============================================

-- 1. CLEANUP
DROP TABLE IF EXISTS shops CASCADE;
DROP TABLE IF EXISTS nexus_identities CASCADE;
DROP TABLE IF EXISTS users CASCADE;
DROP FUNCTION IF EXISTS get_public_hub CASCADE;
DROP FUNCTION IF EXISTS create_user_identity CASCADE;
DROP FUNCTION IF EXISTS handle_new_user CASCADE;

-- 2. USERS TABLE (Linked to Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT NOT NULL,
    email TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. IDENTITIES TABLE (The Digital Card)
CREATE TABLE nexus_identities (
    id TEXT PRIMARY KEY DEFAULT ('nx_' || substr(md5(random()::text), 1, 16)),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    full_name TEXT NOT NULL,
    bio TEXT,
    biometric_style TEXT DEFAULT 'neon-mesh',
    photo_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4. CODES/SHOPS TABLE (Linked to Identity)
CREATE TABLE shops (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    identity_id TEXT REFERENCES nexus_identities(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    name TEXT NOT NULL,
    url TEXT NOT NULL,
    category_id TEXT DEFAULT 'other',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 5. ROW LEVEL SECURITY
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE nexus_identities ENABLE ROW LEVEL SECURITY;
ALTER TABLE shops ENABLE ROW LEVEL SECURITY;

-- Users: Only see own data
CREATE POLICY "Users: Read own profile" ON users FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users: Update own profile" ON users FOR UPDATE USING (auth.uid() = id);

-- Identities: Public read, Private write
CREATE POLICY "Identities: Public read" ON nexus_identities FOR SELECT USING (true);
CREATE POLICY "Identities: Owner manages" ON nexus_identities FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Shops: Public read, Private write
CREATE POLICY "Shops: Public read" ON shops FOR SELECT USING (true);
CREATE POLICY "Shops: Owner manages" ON shops FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- 6. AUTO-CREATE USER PROFILE ON SIGNUP
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO users (id, full_name, email)
    VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'full_name', 'User'),
        NEW.email
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger on auth.users insert
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- 7. RPC: GET PUBLIC IDENTITIES (Fixed column name)
CREATE OR REPLACE FUNCTION get_public_hub(p_limit INTEGER DEFAULT 20)
RETURNS TABLE (
    id TEXT,
    full_name TEXT,
    bio TEXT,
    user_id UUID,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY 
    SELECT ni.id, ni.full_name, ni.bio, ni.user_id, ni.created_at
    FROM nexus_identities ni 
    ORDER BY ni.created_at DESC 
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- 8. RPC: CREATE IDENTITY (For logged-in user)
CREATE OR REPLACE FUNCTION create_user_identity(p_name TEXT, p_bio TEXT)
RETURNS TEXT AS $$
DECLARE
    new_id TEXT;
BEGIN
    -- Check if user already has identity
    IF EXISTS (SELECT 1 FROM nexus_identities WHERE user_id = auth.uid()) THEN
        RAISE EXCEPTION 'User already has an identity';
    END IF;

    new_id := 'nx_' || substr(md5(random()::text), 1, 16);
    INSERT INTO nexus_identities (id, user_id, full_name, bio)
    VALUES (new_id, auth.uid(), p_name, p_bio);
    RETURN new_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 9. NOTIFY SCHEMA RELOAD
NOTIFY pgrst, 'reload schema';
