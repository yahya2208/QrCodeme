-- ============================================
-- TOTAL SYSTEM RECOVERY V8.6 (SAFE DATA RESTORE)
-- ============================================
-- This script fixes signatures and schema while PRESERVING and RESTORING data.

-- 1. PREVENT DATA LOSS: Ensure tables exist with correct structures
CREATE TABLE IF NOT EXISTS nexus_identities (
    id TEXT PRIMARY KEY,
    user_id UUID NOT NULL,
    full_name TEXT,
    bio TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Ensure user_id column exists and has right type if table was empty
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='nexus_identities' AND column_name='user_id') THEN
        ALTER TABLE nexus_identities ADD COLUMN user_id UUID;
    END IF;
END $$;

CREATE TABLE IF NOT EXISTS shops (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    identity_id TEXT REFERENCES nexus_identities(id) ON DELETE CASCADE,
    user_id UUID,
    service_id TEXT,
    name TEXT,
    value TEXT,
    is_public BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS user_points (
    user_id UUID PRIMARY KEY,
    total_points INTEGER DEFAULT 0,
    total_shares INTEGER DEFAULT 0,
    last_share_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS shop_stats (
    shop_id BIGINT PRIMARY KEY,
    total_scans BIGINT DEFAULT 0,
    total_views BIGINT DEFAULT 0,
    last_scan_at TIMESTAMP WITH TIME ZONE,
    last_view_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 2. DATA REPAIR: Deduplicate & Re-link
-- This ensures codes show up even if the identity ID was switched
DO $$ 
DECLARE 
    r RECORD;
    v_target_identity_id TEXT;
BEGIN
    FOR r IN (SELECT DISTINCT user_id FROM shops WHERE user_id IS NOT NULL) LOOP
        -- Get the latest identity for this user
        SELECT id INTO v_target_identity_id FROM nexus_identities WHERE user_id = r.user_id ORDER BY created_at DESC LIMIT 1;
        
        IF v_target_identity_id IS NOT NULL THEN
            -- Link all user's shops to this identity
            UPDATE shops SET identity_id = v_target_identity_id WHERE user_id = r.user_id;
        END IF;
    END LOOP;
END $$;

-- 3. FIX RPC SIGNATURES (CRITICAL for data visibility)
DROP FUNCTION IF EXISTS get_identity_codes(TEXT, UUID) CASCADE;
DROP FUNCTION IF EXISTS get_identity_codes(TEXT) CASCADE;

CREATE OR REPLACE FUNCTION get_identity_codes(p_identity_id TEXT, p_viewer_id UUID DEFAULT NULL)
RETURNS TABLE (
    id BIGINT,
    service_id TEXT,
    service_name TEXT,
    service_icon TEXT,
    service_color TEXT,
    name TEXT,
    display_value TEXT,
    is_owner BOOLEAN,
    owner_name TEXT,
    created_at TIMESTAMP WITH TIME ZONE,
    total_scans BIGINT,
    total_views BIGINT
) AS $$
DECLARE
    v_owner_id UUID;
    v_owner_name TEXT;
BEGIN
    -- Get owner info safely
    SELECT user_id, full_name INTO v_owner_id, v_owner_name 
    FROM nexus_identities WHERE nexus_identities.id = p_identity_id;

    RETURN QUERY
    SELECT 
        s.id,
        s.service_id,
        COALESCE(cs.name, 'Service') AS service_name,
        COALESCE(cs.icon_svg, '') AS service_icon,
        COALESCE(cs.color, '#fff') AS service_color,
        s.name,
        s.value AS display_value,
        (p_viewer_id IS NOT NULL AND p_viewer_id = v_owner_id) AS is_owner,
        COALESCE(v_owner_name, 'Owner') AS owner_name,
        s.created_at,
        COALESCE(st.total_scans, 0) AS total_scans,
        COALESCE(st.total_views, 0) AS total_views
    FROM shops s
    LEFT JOIN code_services cs ON s.service_id = cs.id
    LEFT JOIN shop_stats st ON s.id = st.shop_id
    WHERE s.identity_id = p_identity_id
    ORDER BY s.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4. FIX POINTS RECOVERY
-- Recalculate points if they were lost (5 points per share record)
INSERT INTO user_points (user_id, total_points, total_shares)
SELECT 
    user_id, 
    COUNT(*) * 5 as total_points,
    COUNT(*) as total_shares
FROM share_history
GROUP BY user_id
ON CONFLICT (user_id) DO UPDATE SET
    total_points = GREATEST(user_points.total_points, EXCLUDED.total_points),
    total_shares = GREATEST(user_points.total_shares, EXCLUDED.total_shares);

-- 5. BYPASS RLS (Mandatory for Backend with Anon Key)
ALTER TABLE shops DISABLE ROW LEVEL SECURITY;
ALTER TABLE nexus_identities DISABLE ROW LEVEL SECURITY;
ALTER TABLE user_points DISABLE ROW LEVEL SECURITY;
ALTER TABLE shop_stats DISABLE ROW LEVEL SECURITY;

-- 6. PERMISSIONS
GRANT EXECUTE ON FUNCTION get_identity_codes(TEXT, UUID) TO authenticated, anon;
GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated, anon, service_role;

NOTIFY pgrst, 'reload schema';
